<!DOCTYPE html>
<!-- saved from url=(0034)https://ak-me.com/confSeating.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <script src="chrome-extension://jhgnbkkipaallpehbohjmkbjofjdmeid/steem_keychain.js"></script><script src="chrome-extension://jcacnejopjdphbnjgfaaobbfafkihpep/hive_keychain.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conference Seating Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 30px;
            max-width: 1600px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
            font-size: 2em;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }

        .control-group input[type="range"] {
            width: 100%;
        }

        .control-group input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        .value-display {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.85em;
            font-weight: bold;
        }

        .buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 24px;
            font-size: 1em;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button.build {
            background: #3b82f6;
            color: white;
        }

        button.build:hover:not(:disabled) {
            background: #2563eb;
            transform: translateY(-2px);
        }

        button.start {
            background: #48bb78;
            color: white;
        }

        button.start:hover:not(:disabled) {
            background: #38a169;
            transform: translateY(-2px);
        }

        button.pause {
            background: #ed8936;
            color: white;
        }

        button.pause:hover:not(:disabled) {
            background: #dd6b20;
            transform: translateY(-2px);
        }

        button.reset {
            background: #fc8181;
            color: white;
        }

        button.reset:hover {
            background: #f56565;
            transform: translateY(-2px);
        }

        button.build {
            background: #3b82f6;
            color: white;
        }

        button.build:hover:not(:disabled) {
            background: #2563eb;
            transform: translateY(-2px);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .main-content {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }

        canvas {
            border: 2px solid #333;
            border-radius: 8px;
            background: white;
            display: block;
            margin: 0 auto;
            max-width: 100%;
            height: auto;
        }

        .chart-container {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
        }

        .chart-container h3 {
            text-align: center;
            margin-bottom: 15px;
            color: #333;
        }

        #seatingChart {
            width: 100%;
            height: 400px;
        }

        .stats {
            margin-top: 20px;
            padding: 15px;
            background: #e6fffa;
            border-radius: 10px;
            text-align: center;
            font-size: 1.1em;
            font-weight: 600;
            color: #2c7a7b;
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
            border-radius: 3px;
        }

        .completion-message {
            background: #48bb78;
            color: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 20px;
            display: none;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body data-new-gr-c-s-check-loaded="14.1265.0" data-gr-ext-installed="">
    <div class="container">
        <h1>ðŸŽ¤ Conference Seating Simulation</h1>
        
        <div class="controls">
            <div class="control-group">
                <label>
                    Total Attendees: <span class="value-display" id="agentsValue">384</span>
                </label>
                <input type="range" id="numAgents" min="50" max="500" value="384" step="10">
            </div>

            <div class="control-group">
                <label>
                    Simulation Speed: <span class="value-display" id="speedValue">100ms</span>
                </label>
                <input type="range" id="speed" min="10" max="500" value="100" step="10">
            </div>

            <div class="control-group">
                <label>
                    Max Simulation Time: <span class="value-display" id="maxTimeValue">500</span>
                </label>
                <input type="range" id="maxTime" min="200" max="1000" value="500" step="50">
            </div>

            <div class="control-group">
                <label>
                    Number of Blocks: <span class="value-display" id="blocksValue">4</span>
                </label>
                <input type="range" id="numBlocks" min="2" max="6" value="4">
            </div>

            <div class="control-group">
                <label>
                    Corridor Width: <span class="value-display" id="corridorValue">4</span>
                </label>
                <input type="range" id="corridorWidth" min="2" max="6" value="4">
            </div>

            <div class="control-group">
                <label>
                    Social Distance Preference: <span class="value-display" id="socialValue">8</span>
                </label>
                <input type="range" id="socialDistance" min="0" max="15" value="8">
            </div>

            <div class="control-group">
                <label>
                    Back Row Preference: <span class="value-display" id="backValue">3</span>
                </label>
                <input type="range" id="backPref" min="0" max="10" value="3">
            </div>

            <div class="control-group">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="assignedSeats" checked="">
                    Reserve Assigned Seats
                </label>
            </div>

            <div class="control-group">
                <label style="display: flex; align-items: center; gap: 10px;">
                    <input type="checkbox" id="colorByBlock" checked="">
                    Color Agents by Block
                </label>
            </div>
        </div>

        <div class="buttons">
            <button class="build" id="buildBtn">Build Conference Room</button>
            <button class="start" id="startBtn" disabled="">Start</button>
            <button class="pause" id="pauseBtn" disabled="">Pause</button>
            <button class="reset" id="resetBtn">Reset</button>
        </div>

        <div class="completion-message" id="completionMsg" style="display: none;"></div>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="simCanvas" width="680" height="200"></canvas>
            </div>
            <div class="chart-container">
                <h3>Seating Progress Over Time</h3>
                <canvas id="seatingChart" width="507" height="400" style="width: 507px; height: 400px;"></canvas>
            </div>
        </div>

        <div class="stats" id="stats">Click "Build Conference Room" to start</div>

        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: yellow;"></div>
                <span>Seat</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: lightblue;"></div>
                <span>Corridor</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #00ff00; border: 3px solid #000;"></div>
                <span>Entrance (Gate)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: red;"></div>
                <span>Seated</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #666;"></div>
                <span>Standing</span>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        let config = {
            ROWS: 20,
            COLS: 68,
            NUM_BLOCKS: 4,
            CORRIDOR_WIDTH: 4,
            FEATURE_ASSIGNED_SEATS: true,
            FEATURE_COLOR_BY_BLOCK: true,
            NUM_AGENTS: 384,
            SPEED: 100,
            MAX_TIME: 500,
            SOCIAL_DISTANCE: 8,
            BACK_PREF: 3
        };

        const EMPTY = 0, SEAT = 1, CORRIDOR = 2, GATE = 3;
        const SEATED_AGENT = 9, STANDING = 8;

        const COLORS = {
            [EMPTY]: '#ffffff',
            [SEAT]: '#ffeb3b',
            [CORRIDOR]: '#add8e6',
            [GATE]: '#00ff00',
            [STANDING]: '#666666',
            [SEATED_AGENT]: '#ff0000'
        };

        const BLOCK_COLORS = ['#2196f3', '#ff9800', '#9c27b0', '#00bcd4', '#e91e63', '#8bc34a'];

        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const chartCanvas = document.getElementById('seatingChart');
        const chartCtx = chartCanvas.getContext('2d');
        
        const CELL_SIZE = 10;

        canvas.width = config.COLS * CELL_SIZE;
        canvas.height = config.ROWS * CELL_SIZE;
        
        // Set chart canvas to match container size with high DPI
        function resizeChart() {
            const container = chartCanvas.parentElement;
            const dpr = window.devicePixelRatio || 1;
            chartCanvas.width = container.clientWidth * dpr;
            chartCanvas.height = 400 * dpr;
            chartCanvas.style.width = container.clientWidth + 'px';
            chartCanvas.style.height = '400px';
            chartCtx.scale(dpr, dpr);
        }
        resizeChart();
        window.addEventListener('resize', resizeChart);

        let simulation = null;
        let animationId = null;
        let isRunning = false;
        let isBuilt = false;

        // Chart data
        let chartData = {
            time: [],
            seated: [],
            standing: []
        };

        // Control listeners
        document.getElementById('numAgents').addEventListener('input', (e) => {
            config.NUM_AGENTS = parseInt(e.target.value);
            document.getElementById('agentsValue').textContent = config.NUM_AGENTS;
        });

        document.getElementById('speed').addEventListener('input', (e) => {
            config.SPEED = parseInt(e.target.value);
            document.getElementById('speedValue').textContent = config.SPEED + 'ms';
        });

        document.getElementById('maxTime').addEventListener('input', (e) => {
            config.MAX_TIME = parseInt(e.target.value);
            document.getElementById('maxTimeValue').textContent = config.MAX_TIME;
        });

        document.getElementById('numBlocks').addEventListener('input', (e) => {
            config.NUM_BLOCKS = parseInt(e.target.value);
            document.getElementById('blocksValue').textContent = config.NUM_BLOCKS;
        });

        document.getElementById('corridorWidth').addEventListener('input', (e) => {
            config.CORRIDOR_WIDTH = parseInt(e.target.value);
            document.getElementById('corridorValue').textContent = config.CORRIDOR_WIDTH;
        });

        document.getElementById('socialDistance').addEventListener('input', (e) => {
            config.SOCIAL_DISTANCE = parseInt(e.target.value);
            document.getElementById('socialValue').textContent = config.SOCIAL_DISTANCE;
        });

        document.getElementById('backPref').addEventListener('input', (e) => {
            config.BACK_PREF = parseInt(e.target.value);
            document.getElementById('backValue').textContent = config.BACK_PREF;
        });

        document.getElementById('assignedSeats').addEventListener('change', (e) => {
            config.FEATURE_ASSIGNED_SEATS = e.target.checked;
        });

        document.getElementById('colorByBlock').addEventListener('change', (e) => {
            config.FEATURE_COLOR_BY_BLOCK = e.target.checked;
        });

        document.getElementById('buildBtn').addEventListener('click', build);
        document.getElementById('startBtn').addEventListener('click', start);
        document.getElementById('pauseBtn').addEventListener('click', pause);
        document.getElementById('resetBtn').addEventListener('click', reset);

        // Helper functions
        function generateSeatBlocks(cols, numBlocks, corridorWidth) {
            const totalSeat = cols - (numBlocks + 1) * corridorWidth;
            const blockWidth = Math.floor(totalSeat / numBlocks);
            const blocks = {};
            for (let i = 0; i < numBlocks; i++) {
                const start = corridorWidth + i * (blockWidth + corridorWidth);
                blocks[i] = [start, start + blockWidth - 1];
            }
            return blocks;
        }

        function generateCorridorSegments(cols, seatBlocks, corridorWidth) {
            const segments = [];
            const leftMargin = Array.from({length: corridorWidth}, (_, i) => i);
            segments.push(leftMargin);
            
            for (let i = 0; i < Object.keys(seatBlocks).length; i++) {
                const end = seatBlocks[i][1];
                const seg = Array.from({length: corridorWidth}, (_, j) => end + 1 + j);
                segments.push(seg);
            }
            return segments;
        }

        function buildGrid() {
            const grid = Array(config.ROWS).fill(null).map(() => Array(config.COLS).fill(EMPTY));
            
            const seatBlocks = generateSeatBlocks(config.COLS, config.NUM_BLOCKS, config.CORRIDOR_WIDTH);
            const corridorSegs = generateCorridorSegments(config.COLS, seatBlocks, config.CORRIDOR_WIDTH);
            
            // Fill seats
            for (let r = 6; r < 14; r++) {
                for (let block in seatBlocks) {
                    const [c0, c1] = seatBlocks[block];
                    for (let c = c0; c <= c1; c++) {
                        grid[r][c] = SEAT;
                    }
                }
            }
            
            // Fill corridors
            for (let r = 0; r < config.ROWS; r++) {
                corridorSegs.forEach(seg => {
                    seg.forEach(c => {
                        if (grid[r][c] === EMPTY) grid[r][c] = CORRIDOR;
                    });
                });
            }
            
            // Gates - make them more visible with single highlighted entrance
            const gates = [10, 34, 58].filter(c => c < config.COLS);
            gates.forEach(c => {
                // Mark just the entrance cell
                grid[19][c] = GATE;
            });
            
            return grid;
        }

        function weightedChoice(items, weights) {
            const total = weights.reduce((a, b) => a + b, 0);
            let rnd = Math.random() * total;
            for (let i = 0; i < items.length; i++) {
                rnd -= weights[i];
                if (rnd <= 0) return items[i];
            }
            return items[items.length - 1];
        }

        function pickBlockBasedOnGate(gateCol) {
            if (gateCol <= 10) {
                return weightedChoice([0, 1], [0.75, 0.25]);
            } else if (gateCol <= 34) {
                return weightedChoice([1, 2], [0.25, 0.75]);
            } else {
                return weightedChoice([2, 3], [0.25, 0.75]);
            }
        }

        function pickPreferredCorridorCell(block, seatCol, blockToCorridorCells) {
            const segments = blockToCorridorCells[block];
            if (!segments) return config.CORRIDOR_WIDTH;
            
            const segWeights = segments.map(seg => {
                const d = Math.min(...seg.map(c => Math.abs(seatCol - c)));
                return 1.0 / (d + 1);
            });
            
            const chosenSeg = weightedChoice(segments, segWeights);
            return chosenSeg.reduce((best, c) => 
                Math.abs(seatCol - c) < Math.abs(seatCol - best) ? c : best
            );
        }

        function computeSimplePath(spawn, corridor, seat, row0) {
            const path = [];
            let [r, c] = spawn;
            const [r1, c1] = seat;
            
            if (r !== row0) {
                const step = r > row0 ? -1 : 1;
                for (let rr = r + step; rr !== row0 + step; rr += step) {
                    path.push([rr, c]);
                }
            }
            
            if (c !== corridor) {
                const step = corridor > c ? 1 : -1;
                for (let cc = c + step; cc !== corridor + step; cc += step) {
                    path.push([row0, cc]);
                }
            }
            
            if (row0 > r1) {
                for (let rr = row0 - 1; rr >= r1; rr--) {
                    path.push([rr, corridor]);
                }
            }
            
            if (corridor !== c1) {
                const step = c1 > corridor ? 1 : -1;
                for (let cc = corridor + step; cc !== c1 + step; cc += step) {
                    path.push([r1, cc]);
                }
            }
            
            return path;
        }

        function rowOccupancy(grid, row, c0, c1) {
            let count = 0;
            for (let c = c0; c <= c1; c++) {
                if (grid[row][c] === SEATED_AGENT || grid[row][c] === STANDING) {
                    count++;
                }
            }
            return count;
        }

        function countAdjacentSeated(grid, seat) {
            const [r, c] = seat;
            let count = 0;
            const dirs = [[-1,0], [1,0], [0,-1], [0,1], [-1,-1], [-1,1], [1,-1], [1,1]];
            for (const [dr, dc] of dirs) {
                const rr = r + dr, cc = c + dc;
                if (rr >= 0 && rr < config.ROWS && cc >= 0 && cc < config.COLS) {
                    if (grid[rr][cc] === SEATED_AGENT) count++;
                }
            }
            return count;
        }

        function pickSeatInBlock(grid, block, assigned, seatBlocks, rowThr = 5) {
            const [c0, c1] = seatBlocks[block];
            const valid = [];
            
            for (let r = 6; r < 14; r++) {
                if (rowOccupancy(grid, r, c0, c1) >= rowThr) continue;
                for (let c = c0; c <= c1; c++) {
                    const key = `${r},${c}`;
                    if (grid[r][c] === SEAT && !assigned.has(key)) {
                        let w = 0;
                        
                        w += (13 - r) * config.BACK_PREF;
                        if (Math.min(c - c0, c1 - c) <= 1) w += 5;
                        
                        const adjacentCount = countAdjacentSeated(grid, [r, c]);
                        w += (8 - adjacentCount) * config.SOCIAL_DISTANCE;
                        
                        valid.push([[r, c], Math.max(w, 1)]);
                    }
                }
            }
            
            if (valid.length === 0) return null;
            const seats = valid.map(v => v[0]);
            const weights = valid.map(v => v[1]);
            return weightedChoice(seats, weights);
        }

        function pickSeatAnyBlock(grid, assigned, seatBlocks, rowThr = 5) {
            const blocks = Object.keys(seatBlocks).map(Number);
            const shuffled = blocks.sort(() => Math.random() - 0.5);
            
            for (const b of shuffled) {
                const s = pickSeatInBlock(grid, b, assigned, seatBlocks, rowThr);
                if (s) return [b, s];
            }
            return [null, null];
        }

        function standInBack(grid) {
            // Try to find standing positions in the back rows (14-19)
            // These people will stand anywhere in the back area
            for (const r of [19, 18, 17, 16, 15, 14]) {
                const cand = [];
                
                // Check all columns in this row
                for (let c = 0; c < config.COLS; c++) {
                    const cellType = grid[r][c];
                    // Can stand in corridors or empty spaces, but not on seats or gates
                    if (cellType !== SEAT && 
                        cellType !== GATE && 
                        cellType !== SEATED_AGENT && 
                        cellType !== STANDING) {
                        cand.push([r, c]);
                    }
                }
                
                if (cand.length > 0) {
                    return cand[Math.floor(Math.random() * cand.length)];
                }
            }
            
            // Fallback: any non-seat position in back area
            const r = 14 + Math.floor(Math.random() * 6); // rows 14-19
            const c = Math.floor(Math.random() * config.COLS);
            return [r, c];
        }

        class Agent {
            constructor(grid, spawn, assigned, seatBlocks, blockToCorridorCells) {
                this.pos = spawn;
                this.seated = false;
                this.standing = false;
                const gateC = spawn[1];
                this.block = pickBlockBasedOnGate(gateC);
                
                if (this.block >= Object.keys(seatBlocks).length) {
                    this.block = Object.keys(seatBlocks).length - 1;
                }
                
                let seat = pickSeatInBlock(grid, this.block, assigned, seatBlocks);
                if (!seat) {
                    const [b, s] = pickSeatAnyBlock(grid, assigned, seatBlocks);
                    if (!s) {
                        // No seats available - will stand in back
                        const standPos = standInBack(grid);
                        this.seat = standPos;
                        this.corridor = config.CORRIDOR_WIDTH;
                        this.row0 = 19;
                        this.path = computeSimplePath(this.pos, this.corridor, this.seat, this.row0);
                        this.willStand = true; // Mark that this agent will stand (not seated yet)
                        console.log(`Agent will stand at position [${standPos[0]}, ${standPos[1]}], path length: ${this.path.length}`);
                        return;
                    }
                    this.block = b;
                    seat = s;
                }
                
                if (config.FEATURE_ASSIGNED_SEATS) {
                    assigned.add(`${seat[0]},${seat[1]}`);
                }
                
                this.seat = seat;
                this.corridor = pickPreferredCorridorCell(this.block, this.seat[1], blockToCorridorCells);
                this.row0 = 16 + Math.floor(Math.random() * 4);
                this.path = computeSimplePath(this.pos, this.corridor, this.seat, this.row0);
            }
            
            update(grid) {
                if (this.seated || this.standing) return;
                
                if (this.path.length === 0) {
                    // Reached destination
                    if (this.willStand) {
                        this.standing = true;
                        // Grid already marked when agent was created
                        console.log(`Agent standing at [${this.pos[0]}, ${this.pos[1]}]`);
                    } else if (grid[this.pos[0]][this.pos[1]] === SEAT) {
                        this.seated = true;
                        grid[this.pos[0]][this.pos[1]] = SEATED_AGENT;
                    } else {
                        // Something went wrong, mark as standing
                        this.standing = true;
                        grid[this.pos[0]][this.pos[1]] = STANDING;
                    }
                    return;
                }
                
                this.pos = this.path.shift();
            }
        }

        class Simulation {
            constructor(n) {
                this.grid = buildGrid();
                this.agents = [];
                this.n = n;
                this.spawned = 0;
                
                const gates = [10, 34, 58].filter(c => c < config.COLS);
                this.gates = gates.map(c => [19, c]);
                
                this.time = 0;
                this.assigned = new Set();
                this.totalSeats = this.grid.flat().filter(cell => cell === SEAT).length;
                this.completed = false;
                
                this.seatBlocks = generateSeatBlocks(config.COLS, config.NUM_BLOCKS, config.CORRIDOR_WIDTH);
                this.corridorSegs = generateCorridorSegments(config.COLS, this.seatBlocks, config.CORRIDOR_WIDTH);
                this.blockToCorridorCells = {};
                for (let i = 0; i < config.NUM_BLOCKS; i++) {
                    this.blockToCorridorCells[i] = [this.corridorSegs[i], this.corridorSegs[i + 1]];
                }
                
                chartData = { time: [], seated: [], standing: [] };
            }
            
            update() {
                if (this.completed) return;
                
                const occ = new Set();
                this.agents.forEach(a => {
                    if (!a.seated && !a.standing) occ.add(`${a.pos[0]},${a.pos[1]}`);
                });
                
                for (const g of this.gates) {
                    const key = `${g[0]},${g[1]}`;
                    if (this.spawned < this.n && !occ.has(key)) {
                        const ag = new Agent(this.grid, g, this.assigned, this.seatBlocks, this.blockToCorridorCells);
                        this.agents.push(ag);
                        this.spawned++;
                        occ.add(key);
                        
                        // Reserve the destination for standing agents
                        if (ag.willStand && ag.seat) {
                            this.grid[ag.seat[0]][ag.seat[1]] = STANDING;
                        }
                    }
                }
                
                this.agents.forEach(ag => {
                    if (!ag.seated && !ag.standing) ag.update(this.grid);
                });
                
                this.time++;
                
                const seated = this.agents.filter(a => a.seated).length;
                const standing = this.agents.filter(a => a.standing).length;
                chartData.time.push(this.time);
                chartData.seated.push(seated);
                chartData.standing.push(standing);
                
                const allSettled = this.agents.every(a => a.seated || a.standing);
                if ((allSettled && this.spawned >= this.n) || this.time >= config.MAX_TIME) {
                    this.completed = true;
                    this.showCompletionMessage(seated, standing);
                    pause();
                }
            }
            
            showCompletionMessage(seated, standing) {
                const msg = document.getElementById('completionMsg');
                const seatedPercent = this.spawned > 0 ? ((seated / this.spawned) * 100).toFixed(1) : 0;
                msg.textContent = `âœ… Simulation Complete! Time: ${this.time} ticks | ${seated} seated (${seatedPercent}%), ${standing} standing`;
                msg.style.display = 'block';
            }
            
            draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw grid
                for (let r = 0; r < config.ROWS; r++) {
                    for (let c = 0; c < config.COLS; c++) {
                        const cellValue = this.grid[r][c];
                        ctx.fillStyle = COLORS[cellValue];
                        ctx.fillRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        
                        // Extra border for gates
                        if (cellValue === GATE) {
                            ctx.strokeStyle = '#000';
                            ctx.lineWidth = 2;
                            ctx.strokeRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        } 
                        // Border for standing agents
                        else if (cellValue === STANDING) {
                            ctx.strokeStyle = '#333';
                            ctx.lineWidth = 1;
                            ctx.strokeRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                        else {
                            ctx.strokeStyle = '#ddd';
                            ctx.lineWidth = 0.5;
                            ctx.strokeRect(c * CELL_SIZE, r * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                    }
                }
                
                // No need to draw standing agents separately anymore since they're in the grid
                
                // Draw moving agents
                this.agents.forEach(ag => {
                    if (!ag.seated && !ag.standing) {
                        const [r, c] = ag.pos;
                        // Different color for agents going to stand vs going to sit
                        if (ag.willStand) {
                            ctx.fillStyle = '#999'; // Gray for standing agents
                        } else {
                            ctx.fillStyle = config.FEATURE_COLOR_BY_BLOCK ? BLOCK_COLORS[ag.block % BLOCK_COLORS.length] : 'black';
                        }
                        ctx.beginPath();
                        ctx.arc(c * CELL_SIZE + CELL_SIZE / 2, r * CELL_SIZE + CELL_SIZE / 2, CELL_SIZE / 2.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                // Update stats
                const seated = this.agents.filter(a => a.seated).length;
                const standing = this.agents.filter(a => a.standing).length;
                const moving = this.agents.filter(a => !a.seated && !a.standing).length;
                const seatedPercent = this.spawned > 0 ? ((seated / this.spawned) * 100).toFixed(1) : 0;
                document.getElementById('stats').textContent = 
                    `Time: ${this.time} | Arrived: ${this.spawned} | Moving: ${moving} | Seated: ${seated} (${seatedPercent}%) | Standing: ${standing}`;
                
                // Draw chart
                drawChart();
            }
        }

        function drawChart() {
            if (chartData.time.length === 0) return;
            
            const container = chartCanvas.parentElement;
            const displayWidth = container.clientWidth;
            const displayHeight = 400;
            
            chartCtx.clearRect(0, 0, displayWidth, displayHeight);
            
            const padding = 50;
            const width = displayWidth - 2 * padding;
            const height = displayHeight - 2 * padding;
            
            const maxTime = Math.max(...chartData.time, 1);
            const maxValue = Math.max(...chartData.seated, ...chartData.standing, 1);
            
            // Draw background
            chartCtx.fillStyle = '#ffffff';
            chartCtx.fillRect(0, 0, displayWidth, displayHeight);
            
            // Draw grid lines
            chartCtx.strokeStyle = '#e0e0e0';
            chartCtx.lineWidth = 1;
            for (let i = 0; i <= 5; i++) {
                const y = padding + (i * height) / 5;
                chartCtx.beginPath();
                chartCtx.moveTo(padding, y);
                chartCtx.lineTo(padding + width, y);
                chartCtx.stroke();
            }
            
            // Draw axes
            chartCtx.strokeStyle = '#333';
            chartCtx.lineWidth = 2;
            chartCtx.beginPath();
            chartCtx.moveTo(padding, padding);
            chartCtx.lineTo(padding, padding + height);
            chartCtx.lineTo(padding + width, padding + height);
            chartCtx.stroke();
            
            // Draw seated line
            if (chartData.seated.length > 1) {
                chartCtx.strokeStyle = '#ff0000';
                chartCtx.lineWidth = 3;
                chartCtx.beginPath();
                for (let i = 0; i < chartData.time.length; i++) {
                    const x = padding + (chartData.time[i] / maxTime) * width;
                    const y = padding + height - (chartData.seated[i] / maxValue) * height;
                    if (i === 0) chartCtx.moveTo(x, y);
                    else chartCtx.lineTo(x, y);
                }
                chartCtx.stroke();
            }
            
            // Draw standing line
            if (chartData.standing.length > 1) {
                chartCtx.strokeStyle = '#666';
                chartCtx.lineWidth = 3;
                chartCtx.beginPath();
                for (let i = 0; i < chartData.time.length; i++) {
                    const x = padding + (chartData.time[i] / maxTime) * width;
                    const y = padding + height - (chartData.standing[i] / maxValue) * height;
                    if (i === 0) chartCtx.moveTo(x, y);
                    else chartCtx.lineTo(x, y);
                }
                chartCtx.stroke();
            }
            
            // Y-axis labels
            chartCtx.fillStyle = '#333';
            chartCtx.font = '12px Arial';
            chartCtx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const value = Math.round((maxValue / 5) * (5 - i));
                const y = padding + (i * height) / 5;
                chartCtx.fillText(value.toString(), padding - 10, y + 4);
            }
            
            // X-axis labels
            chartCtx.textAlign = 'center';
            for (let i = 0; i <= 5; i++) {
                const value = Math.round((maxTime / 5) * i);
                const x = padding + (i * width) / 5;
                chartCtx.fillText(value.toString(), x, padding + height + 20);
            }
            
            // Axis titles
            chartCtx.font = 'bold 14px Arial';
            chartCtx.fillText('Time (ticks)', displayWidth / 2, displayHeight - 10);
            
            chartCtx.save();
            chartCtx.translate(15, displayHeight / 2);
            chartCtx.rotate(-Math.PI / 2);
            chartCtx.fillText('Number of People', 0, 0);
            chartCtx.restore();
            
            // Legend
            chartCtx.textAlign = 'left';
            chartCtx.font = '12px Arial';
            
            chartCtx.fillStyle = '#ff0000';
            chartCtx.fillRect(displayWidth - 110, 20, 20, 3);
            chartCtx.fillStyle = '#333';
            chartCtx.fillText('Seated', displayWidth - 85, 25);
            
            chartCtx.fillStyle = '#666';
            chartCtx.fillRect(displayWidth - 110, 40, 20, 3);
            chartCtx.fillStyle = '#333';
            chartCtx.fillText('Standing', displayWidth - 85, 45);
        }

        function start() {
            console.log("Start button clicked, isBuilt:", isBuilt);
            if (!isBuilt) {
                console.log("Not built yet, building first...");
                build();
            }
            if (!isRunning) {
                isRunning = true;
                document.getElementById('pauseBtn').disabled = false;
                animate();
            }
        }

        function pause() {
            isRunning = false;
            if (animationId) {
                clearTimeout(animationId);
            }
        }

        function reset() {
            pause();
            simulation = null;
            isBuilt = false;
            chartData = { time: [], seated: [], standing: [] };
            
            // Clear canvases
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const container = chartCanvas.parentElement;
            chartCtx.clearRect(0, 0, container.clientWidth, 400);
            
            // Hide completion message
            document.getElementById('completionMsg').style.display = 'none';
            
            // Reset button states
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('buildBtn').disabled = false;
            
            // Reset stats
            document.getElementById('stats').textContent = 'Click "Build Conference Room" to start';
            
            console.log("Reset complete");
        }

        function animate() {
            if (!isRunning) return;
            
            simulation.update();
            simulation.draw();
            
            animationId = setTimeout(animate, config.SPEED);
        }

        // Build function
        function build() {
            console.log("Building conference room...");
            simulation = new Simulation(config.NUM_AGENTS);
            simulation.draw();
            isBuilt = true;
            
            // Enable start button, disable build button
            document.getElementById('startBtn').disabled = false;
            document.getElementById('buildBtn').disabled = true;
            
            console.log("Conference room built!");
        }

        // Initial setup
        reset();
    </script>

</body><grammarly-desktop-integration data-grammarly-shadow-root="true"><template shadowrootmode="open"><style>
      div.grammarly-desktop-integration {
        position: absolute;
        width: 1px;
        height: 1px;
        padding: 0;
        margin: -1px;
        overflow: hidden;
        clip: rect(0, 0, 0, 0);
        white-space: nowrap;
        border: 0;
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select:none;
        user-select:none;
      }

      div.grammarly-desktop-integration:before {
        content: attr(data-content);
      }
    </style><div aria-label="grammarly-integration" role="group" tabindex="-1" class="grammarly-desktop-integration" data-content="{&quot;mode&quot;:&quot;full&quot;,&quot;isActive&quot;:true,&quot;isUserDisabled&quot;:false}"></div></template></grammarly-desktop-integration></html>